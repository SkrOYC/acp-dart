import 'package:json_annotation/json_annotation.dart';

import 'content_block_converter.dart';
import 'embedded_resource_converter.dart';
import 'session_update_converter.dart';
import 'tool_call_content_converter.dart';
import 'mcp_server_converter.dart';
import 'request_permission_converter.dart';
part 'schema.g.dart';

typedef ProtocolVersion = int;
typedef SessionId = String;
typedef SessionModeId = String;
typedef ModelId = String;
typedef AuthMethodId = String;
typedef ToolCallId = String;
typedef PermissionOptionId = String;

/// Base class for all MCP Server definitions (HTTP, SSE, Stdio).
abstract class McpServerBase {}

/// The sender or recipient of messages and data in a conversation.
///
/// Roles help identify whether content originated from the user, the AI assistant,
/// or other participants in the conversation. This is essential for maintaining
/// proper context and attribution in multi-turn conversations.
///
/// See protocol docs: [Content](https://agentclientprotocol.com/protocol/content)
enum Role {
  /// Content generated by an AI assistant or agent
  assistant,

  /// Content provided by the human user
  user,
}

/// Categories of tools that can be invoked.
///
/// Tool kinds help clients choose appropriate icons and optimize how they
/// display tool execution progress. Different tool kinds may have different
/// permission requirements and user interaction patterns.
///
/// See protocol docs: [Creating](https://agentclientprotocol.com/protocol/tool-calls#creating)
enum ToolKind {
  /// Tools that read or access data without modification
  read,

  /// Tools that modify existing files or data
  edit,

  /// Tools that remove files or data
  delete,

  /// Tools that relocate files or data
  move,

  /// Tools that search for information
  search,

  /// Tools that execute commands or run processes
  execute,

  /// Tools that perform internal reasoning (may not require user permission)
  think,

  /// Tools that retrieve data from external sources
  fetch,

  /// Tools that change the agent's operational mode
  @JsonValue('switch_mode')
  switchMode,

  /// Tools that don't fit other categories
  other,
}

/// Execution status of a tool call.
///
/// Tool calls progress through different statuses during their lifecycle.
/// Clients use these statuses to provide appropriate feedback to users
/// about the progress of tool execution.
///
/// See protocol docs: [Status](https://agentclientprotocol.com/protocol/tool-calls#status)
enum ToolCallStatus {
  /// Tool call has been created but not yet started
  pending,

  /// Tool call is currently executing
  @JsonValue('in_progress')
  inProgress,

  /// Tool call completed successfully
  completed,

  /// Tool call failed to complete
  failed,
}

/// Reasons why an agent stops processing a prompt turn.
///
/// See protocol docs: [Stop Reasons](https://agentclientprotocol.com/protocol/prompt-turn#stop-reasons)
enum StopReason {
  /// The turn ended successfully.
  @JsonValue('end_turn')
  endTurn,

  /// The turn ended because the agent reached the maximum number of tokens.
  @JsonValue('max_tokens')
  maxTokens,

  /// The turn ended because the agent reached the maximum number of allowed
  /// agent requests between user turns.
  @JsonValue('max_turn_requests')
  maxTurnRequests,

  /// The turn ended because the agent refused to continue. The user prompt
  /// and everything that comes after it won't be included in the next
  /// prompt, so this should be reflected in the UI.
  refusal,

  /// The turn was cancelled by the client via `session/cancel`.
  @JsonValue('cancelled')
  cancelled,
}

@JsonSerializable()
class InitializeRequest {
  @JsonKey(name: '_meta', includeIfNull: false)
  final Map<String, dynamic>? meta;
  @JsonKey(name: 'clientCapabilities')
  final ClientCapabilities? clientCapabilities;
  final int protocolVersion;

  InitializeRequest({
    this.meta,
    this.clientCapabilities,
    required this.protocolVersion,
  });

  factory InitializeRequest.fromJson(Map<String, dynamic> json) =>
      _$InitializeRequestFromJson(json);

  Map<String, dynamic> toJson() => _$InitializeRequestToJson(this);
}

@JsonSerializable()
class ClientCapabilities {
  @JsonKey(name: '_meta', includeIfNull: false)
  final Map<String, dynamic>? meta;
  final FileSystemCapability? fs;
  @JsonKey(defaultValue: false)
  final bool terminal;

  ClientCapabilities({this.meta, this.fs, this.terminal = false});

  factory ClientCapabilities.fromJson(Map<String, dynamic> json) =>
      _$ClientCapabilitiesFromJson(json);

  Map<String, dynamic> toJson() => _$ClientCapabilitiesToJson(this);
}

@JsonSerializable()
class FileSystemCapability {
  @JsonKey(name: '_meta', includeIfNull: false)
  final Map<String, dynamic>? meta;
  @JsonKey(defaultValue: false)
  final bool readTextFile;
  @JsonKey(defaultValue: false)
  final bool writeTextFile;

  FileSystemCapability({
    this.meta,
    this.readTextFile = false,
    this.writeTextFile = false,
  });

  factory FileSystemCapability.fromJson(Map<String, dynamic> json) =>
      _$FileSystemCapabilityFromJson(json);

  Map<String, dynamic> toJson() => _$FileSystemCapabilityToJson(this);
}

@JsonSerializable()
class AuthenticateRequest {
  @JsonKey(name: '_meta', includeIfNull: false)
  final Map<String, dynamic>? meta;
  @JsonKey(name: 'methodId')
  final String methodId;

  AuthenticateRequest({this.meta, required this.methodId});

  factory AuthenticateRequest.fromJson(Map<String, dynamic> json) =>
      _$AuthenticateRequestFromJson(json);

  Map<String, dynamic> toJson() => _$AuthenticateRequestToJson(this);
}

@JsonSerializable()
class NewSessionRequest {
  @JsonKey(name: '_meta', includeIfNull: false)
  final Map<String, dynamic>? meta;
  final String cwd;
  @McpServerConverter()
  final List<McpServerBase> mcpServers;

  NewSessionRequest({this.meta, required this.cwd, required this.mcpServers});

  factory NewSessionRequest.fromJson(Map<String, dynamic> json) =>
      _$NewSessionRequestFromJson(json);

  Map<String, dynamic> toJson() => _$NewSessionRequestToJson(this);
}

@JsonSerializable()
class HttpMcpServer extends McpServerBase {
  @JsonKey(name: '_meta', includeIfNull: false)
  final Map<String, dynamic>? meta;
  @JsonKey(defaultValue: 'http')
  final String type;
  final String name;
  final String url;
  final List<HttpHeader> headers;

  HttpMcpServer({
    this.meta,
    this.type = 'http',
    required this.name,
    required this.url,
    required this.headers,
  });

  factory HttpMcpServer.fromJson(Map<String, dynamic> json) =>
      _$HttpMcpServerFromJson(json);

  Map<String, dynamic> toJson() => _$HttpMcpServerToJson(this);
}

@JsonSerializable()
class SseMcpServer extends McpServerBase {
  @JsonKey(name: '_meta', includeIfNull: false)
  final Map<String, dynamic>? meta;
  @JsonKey(defaultValue: 'sse')
  final String type;
  final String name;
  final String url;
  final List<HttpHeader> headers;

  SseMcpServer({
    this.meta,
    this.type = 'sse',
    required this.name,
    required this.url,
    required this.headers,
  });

  factory SseMcpServer.fromJson(Map<String, dynamic> json) =>
      _$SseMcpServerFromJson(json);

  Map<String, dynamic> toJson() => _$SseMcpServerToJson(this);
}

@JsonSerializable()
class HttpHeader {
  @JsonKey(name: '_meta', includeIfNull: false)
  final Map<String, dynamic>? meta;
  final String name;
  final String value;

  HttpHeader({this.meta, required this.name, required this.value});

  factory HttpHeader.fromJson(Map<String, dynamic> json) =>
      _$HttpHeaderFromJson(json);

  Map<String, dynamic> toJson() => _$HttpHeaderToJson(this);
}

@JsonSerializable()
class StdioMcpServer extends McpServerBase {
  @JsonKey(name: '_meta', includeIfNull: false)
  final Map<String, dynamic>? meta;
  final List<String> args;
  final String command;
  final List<EnvVariable> env;
  final String name;

  StdioMcpServer({
    this.meta,
    required this.args,
    required this.command,
    required this.env,
    required this.name,
  });

  factory StdioMcpServer.fromJson(Map<String, dynamic> json) =>
      _$StdioMcpServerFromJson(json);

  Map<String, dynamic> toJson() => _$StdioMcpServerToJson(this);
}

@JsonSerializable()
class EnvVariable {
  @JsonKey(name: '_meta', includeIfNull: false)
  final Map<String, dynamic>? meta;
  final String name;
  final String value;

  EnvVariable({this.meta, required this.name, required this.value});

  factory EnvVariable.fromJson(Map<String, dynamic> json) =>
      _$EnvVariableFromJson(json);

  Map<String, dynamic> toJson() => _$EnvVariableToJson(this);
}

@JsonSerializable()
class LoadSessionRequest {
  @JsonKey(name: '_meta', includeIfNull: false)
  final Map<String, dynamic>? meta;
  final String cwd;
  @McpServerConverter()
  final List<McpServerBase> mcpServers;
  final String sessionId;

  LoadSessionRequest({
    this.meta,
    required this.cwd,
    required this.mcpServers,
    required this.sessionId,
  });

  factory LoadSessionRequest.fromJson(Map<String, dynamic> json) =>
      _$LoadSessionRequestFromJson(json);

  Map<String, dynamic> toJson() => _$LoadSessionRequestToJson(this);
}

@JsonSerializable()
class SetSessionModeRequest {
  @JsonKey(name: '_meta', includeIfNull: false)
  final Map<String, dynamic>? meta;
  final String sessionId;
  final String modeId;

  SetSessionModeRequest({
    this.meta,
    required this.sessionId,
    required this.modeId,
  });

  factory SetSessionModeRequest.fromJson(Map<String, dynamic> json) =>
      _$SetSessionModeRequestFromJson(json);

  Map<String, dynamic> toJson() => _$SetSessionModeRequestToJson(this);
}

@JsonSerializable()
class PromptRequest {
  @JsonKey(name: '_meta', includeIfNull: false)
  final Map<String, dynamic>? meta;

  /// The ID of the session this prompt belongs to
  final String sessionId;

  /// Structured content blocks representing the user's message
  @ContentBlockConverter()
  final List<ContentBlock> prompt;

  /// Request parameters for sending a user prompt to the agent.
  ///
  /// Contains the user's message and any additional context or tools.
  /// The agent will process this prompt and return a response with the
  /// stop reason and any generated content or tool calls.
  ///
  /// See protocol docs: [User Message](https://agentclientprotocol.com/protocol/prompt-turn#1-user-message)
  PromptRequest({this.meta, required this.sessionId, required this.prompt});

  factory PromptRequest.fromJson(Map<String, dynamic> json) =>
      _$PromptRequestFromJson(json);

  Map<String, dynamic> toJson() => _$PromptRequestToJson(this);
}

/// Content produced by a user or agent.
///
/// This structure is compatible with the Model Context Protocol (MCP), enabling
/// agents to seamlessly forward content from MCP tool outputs without transformation.
///
/// See protocol docs: [Content](https://agentclientprotocol.com/protocol/content)
abstract class ContentBlock {}

@JsonSerializable()
class TextContentBlock extends ContentBlock {
  @JsonKey(name: '_meta', includeIfNull: false)
  final Map<String, dynamic>? meta;
  final Annotations? annotations;
  final String text;
  @JsonKey(name: 'type')
  final String type;

  TextContentBlock({
    this.meta,
    this.annotations,
    required this.text,
    this.type = 'text',
  });

  factory TextContentBlock.fromJson(Map<String, dynamic> json) =>
      _$TextContentBlockFromJson(json);

  Map<String, dynamic> toJson() => _$TextContentBlockToJson(this);

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is TextContentBlock &&
          runtimeType == other.runtimeType &&
          meta == other.meta &&
          annotations == other.annotations &&
          text == other.text &&
          type == other.type;

  @override
  int get hashCode => Object.hash(meta, annotations, text, type);
}

@JsonSerializable()
class ImageContentBlock extends ContentBlock {
  @JsonKey(name: '_meta', includeIfNull: false)
  final Map<String, dynamic>? meta;
  final Annotations? annotations;
  final String data;
  final String mimeType;
  final String? uri;
  @JsonKey(name: 'type')
  final String type;

  ImageContentBlock({
    this.meta,
    this.annotations,
    required this.data,
    required this.mimeType,
    this.uri,
    this.type = 'image',
  });

  factory ImageContentBlock.fromJson(Map<String, dynamic> json) =>
      _$ImageContentBlockFromJson(json);

  Map<String, dynamic> toJson() => _$ImageContentBlockToJson(this);

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ImageContentBlock &&
          runtimeType == other.runtimeType &&
          meta == other.meta &&
          annotations == other.annotations &&
          data == other.data &&
          mimeType == other.mimeType &&
          uri == other.uri &&
          type == other.type;

  @override
  int get hashCode => Object.hash(meta, annotations, data, mimeType, uri, type);
}

@JsonSerializable()
class AudioContentBlock extends ContentBlock {
  @JsonKey(name: '_meta', includeIfNull: false)
  final Map<String, dynamic>? meta;
  final Annotations? annotations;
  final String data;
  final String mimeType;
  @JsonKey(name: 'type', defaultValue: 'audio')
  final String type;

  AudioContentBlock({
    this.meta,
    this.annotations,
    required this.data,
    required this.mimeType,
    this.type = 'audio',
  });

  factory AudioContentBlock.fromJson(Map<String, dynamic> json) =>
      _$AudioContentBlockFromJson(json);

  Map<String, dynamic> toJson() => _$AudioContentBlockToJson(this);
}

@JsonSerializable()
class ResourceLinkContentBlock extends ContentBlock {
  @JsonKey(name: '_meta', includeIfNull: false)
  final Map<String, dynamic>? meta;
  final Annotations? annotations;
  final String? description;
  final String? mimeType;
  final String name;
  final int? size;
  final String? title;
  final String uri;
  @JsonKey(name: 'type')
  final String type;

  ResourceLinkContentBlock({
    this.meta,
    this.annotations,
    this.description,
    this.mimeType,
    required this.name,
    this.size,
    this.title,
    required this.uri,
    this.type = 'resource_link',
  });

  factory ResourceLinkContentBlock.fromJson(Map<String, dynamic> json) =>
      _$ResourceLinkContentBlockFromJson(json);

  Map<String, dynamic> toJson() => _$ResourceLinkContentBlockToJson(this);

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ResourceLinkContentBlock &&
          runtimeType == other.runtimeType &&
          meta == other.meta &&
          annotations == other.annotations &&
          description == other.description &&
          mimeType == other.mimeType &&
          name == other.name &&
          size == other.size &&
          title == other.title &&
          uri == other.uri &&
          type == other.type;

  @override
  int get hashCode => Object.hash(
    meta,
    annotations,
    description,
    mimeType,
    name,
    size,
    title,
    uri,
    type,
  );
}

@JsonSerializable()
class ResourceContentBlock extends ContentBlock {
  @JsonKey(name: '_meta', includeIfNull: false)
  final Map<String, dynamic>? meta;
  final Annotations? annotations;
  final EmbeddedResource resource;
  @JsonKey(name: 'type')
  final String type;

  ResourceContentBlock({
    this.meta,
    this.annotations,
    required this.resource,
    this.type = 'resource',
  });

  factory ResourceContentBlock.fromJson(Map<String, dynamic> json) =>
      _$ResourceContentBlockFromJson(json);

  Map<String, dynamic> toJson() => _$ResourceContentBlockToJson(this);
}

@JsonSerializable()
class ToolCall {
  @JsonKey(name: '_meta', includeIfNull: false)
  final Map<String, dynamic>? meta;
  @ToolCallContentConverter()
  final List<ToolCallContent>? content;
  final ToolKind? kind;
  final List<ToolCallLocation>? locations;
  final Map<String, dynamic>? rawInput;
  final Map<String, dynamic>? rawOutput;
  final ToolCallStatus? status;
  final String title;
  final String toolCallId;

  ToolCall({
    this.meta,
    this.content,
    this.kind,
    this.locations,
    this.rawInput,
    this.rawOutput,
    this.status,
    required this.title,
    required this.toolCallId,
  });

  factory ToolCall.fromJson(Map<String, dynamic> json) =>
      _$ToolCallFromJson(json);

  Map<String, dynamic> toJson() => _$ToolCallToJson(this);
}

@JsonSerializable()
class SetSessionModelRequest {
  @JsonKey(name: '_meta', includeIfNull: false)
  final Map<String, dynamic>? meta;
  @JsonKey(name: 'modelId')
  final String modelId;
  final String sessionId;

  SetSessionModelRequest({
    this.meta,
    required this.modelId,
    required this.sessionId,
  });

  factory SetSessionModelRequest.fromJson(Map<String, dynamic> json) =>
      _$SetSessionModelRequestFromJson(json);

  Map<String, dynamic> toJson() => _$SetSessionModelRequestToJson(this);
}

@JsonSerializable()
class WriteTextFileRequest {
  @JsonKey(name: '_meta', includeIfNull: false)
  final Map<String, dynamic>? meta;
  final String sessionId;
  final String path;
  final String content;

  WriteTextFileRequest({
    this.meta,
    required this.sessionId,
    required this.path,
    required this.content,
  });

  factory WriteTextFileRequest.fromJson(Map<String, dynamic> json) =>
      _$WriteTextFileRequestFromJson(json);

  Map<String, dynamic> toJson() => _$WriteTextFileRequestToJson(this);
}

@JsonSerializable()
class ReadTextFileRequest {
  @JsonKey(name: '_meta', includeIfNull: false)
  final Map<String, dynamic>? meta;
  final String sessionId;
  final String path;
  final int? line;
  final int? limit;

  ReadTextFileRequest({
    this.meta,
    required this.sessionId,
    required this.path,
    this.line,
    this.limit,
  });

  factory ReadTextFileRequest.fromJson(Map<String, dynamic> json) =>
      _$ReadTextFileRequestFromJson(json);

  Map<String, dynamic> toJson() => _$ReadTextFileRequestToJson(this);
}

@JsonSerializable()
class RequestPermissionRequest {
  @JsonKey(name: '_meta', includeIfNull: false)
  final Map<String, dynamic>? meta;
  final String sessionId;
  final List<PermissionOption> options;
  final ToolCallUpdate toolCall;

  RequestPermissionRequest({
    this.meta,
    required this.sessionId,
    required this.options,
    required this.toolCall,
  });

  factory RequestPermissionRequest.fromJson(Map<String, dynamic> json) =>
      _$RequestPermissionRequestFromJson(json);

  Map<String, dynamic> toJson() => _$RequestPermissionRequestToJson(this);
}

@JsonSerializable()
class PermissionOption {
  @JsonKey(name: '_meta', includeIfNull: false)
  final Map<String, dynamic>? meta;
  @JsonKey(name: 'optionId')
  final String optionId;
  final String name;
  final PermissionOptionKind kind;

  PermissionOption({
    this.meta,
    required this.optionId,
    required this.name,
    required this.kind,
  });

  factory PermissionOption.fromJson(Map<String, dynamic> json) =>
      _$PermissionOptionFromJson(json);

  Map<String, dynamic> toJson() => _$PermissionOptionToJson(this);
}

enum PermissionOptionKind {
  @JsonValue('allow_once')
  allowOnce,
  @JsonValue('allow_always')
  allowAlways,
  @JsonValue('reject_once')
  rejectOnce,
  @JsonValue('reject_always')
  rejectAlways,
}

@JsonSerializable()
class ToolCallUpdate {
  @JsonKey(name: '_meta', includeIfNull: false)
  final Map<String, dynamic>? meta;
  @ToolCallContentConverter()
  final List<ToolCallContent>? content;
  final ToolKind? kind;
  final List<ToolCallLocation>? locations;
  final Map<String, dynamic>? rawInput;
  final Map<String, dynamic>? rawOutput;
  final ToolCallStatus? status;
  final String? title;
  final String toolCallId;

  ToolCallUpdate({
    this.meta,
    this.content,
    this.kind,
    this.locations,
    this.rawInput,
    this.rawOutput,
    this.status,
    this.title,
    required this.toolCallId,
  });

  factory ToolCallUpdate.fromJson(Map<String, dynamic> json) =>
      _$ToolCallUpdateFromJson(json);

  Map<String, dynamic> toJson() => _$ToolCallUpdateToJson(this);
}

@JsonSerializable()
class CreateTerminalRequest {
  @JsonKey(name: '_meta', includeIfNull: false)
  final Map<String, dynamic>? meta;
  final String sessionId;

  /// The command to execute in the terminal
  final String command;

  /// Arguments to pass to the command
  final List<String>? args;

  /// Working directory for the command (defaults to current directory)
  final String? cwd;

  /// Environment variables to set for the command
  final List<EnvVariable>? env;

  /// Optional limit for terminal output bytes returned in responses.
  final int? outputByteLimit;

  /// Request to create a new terminal and execute a command.
  ///
  /// Creates a new terminal session and executes the specified command.
  /// Returns a TerminalHandle that can be used to monitor output,
  /// wait for completion, or control the terminal.
  ///
  /// The terminal can also be embedded in tool calls by referencing its ID
  /// in ToolCallContent with type "terminal".
  CreateTerminalRequest({
    this.meta,
    required this.sessionId,
    required this.command,
    this.args,
    this.cwd,
    this.env,
    this.outputByteLimit,
  });

  factory CreateTerminalRequest.fromJson(Map<String, dynamic> json) =>
      _$CreateTerminalRequestFromJson(json);

  Map<String, dynamic> toJson() => _$CreateTerminalRequestToJson(this);
}

@JsonSerializable()
class TerminalOutputRequest {
  @JsonKey(name: '_meta', includeIfNull: false)
  final Map<String, dynamic>? meta;
  final String sessionId;
  final String terminalId;

  TerminalOutputRequest({
    this.meta,
    required this.sessionId,
    required this.terminalId,
  });

  factory TerminalOutputRequest.fromJson(Map<String, dynamic> json) =>
      _$TerminalOutputRequestFromJson(json);

  Map<String, dynamic> toJson() => _$TerminalOutputRequestToJson(this);
}

@JsonSerializable()
class ReleaseTerminalRequest {
  @JsonKey(name: '_meta', includeIfNull: false)
  final Map<String, dynamic>? meta;
  final String sessionId;
  final String terminalId;

  ReleaseTerminalRequest({
    this.meta,
    required this.sessionId,
    required this.terminalId,
  });

  factory ReleaseTerminalRequest.fromJson(Map<String, dynamic> json) =>
      _$ReleaseTerminalRequestFromJson(json);

  Map<String, dynamic> toJson() => _$ReleaseTerminalRequestToJson(this);
}

@JsonSerializable()
class WaitForTerminalExitRequest {
  @JsonKey(name: '_meta', includeIfNull: false)
  final Map<String, dynamic>? meta;
  final String sessionId;
  final String terminalId;

  WaitForTerminalExitRequest({
    this.meta,
    required this.sessionId,
    required this.terminalId,
  });

  factory WaitForTerminalExitRequest.fromJson(Map<String, dynamic> json) =>
      _$WaitForTerminalExitRequestFromJson(json);

  Map<String, dynamic> toJson() => _$WaitForTerminalExitRequestToJson(this);
}

@JsonSerializable()
class KillTerminalCommandRequest {
  @JsonKey(name: '_meta', includeIfNull: false)
  final Map<String, dynamic>? meta;
  final String sessionId;
  final String terminalId;

  KillTerminalCommandRequest({
    this.meta,
    required this.sessionId,
    required this.terminalId,
  });

  factory KillTerminalCommandRequest.fromJson(Map<String, dynamic> json) =>
      _$KillTerminalCommandRequestFromJson(json);

  Map<String, dynamic> toJson() => _$KillTerminalCommandRequestToJson(this);
}

@JsonSerializable()
class InitializeResponse {
  @JsonKey(name: '_meta', includeIfNull: false)
  final Map<String, dynamic>? meta;
  final int protocolVersion;
  @JsonKey(name: 'agentCapabilities')
  final AgentCapabilities? agentCapabilities;
  @JsonKey(defaultValue: <AuthMethod>[])
  final List<AuthMethod> authMethods;

  InitializeResponse({
    this.meta,
    required this.protocolVersion,
    this.agentCapabilities,
    List<AuthMethod>? authMethods,
  }) : authMethods = authMethods ?? const [];

  factory InitializeResponse.fromJson(Map<String, dynamic> json) =>
      _$InitializeResponseFromJson(json);

  Map<String, dynamic> toJson() => _$InitializeResponseToJson(this);
}

@JsonSerializable()
class AgentCapabilities {
  @JsonKey(name: '_meta', includeIfNull: false)
  final Map<String, dynamic>? meta;
  @JsonKey(name: 'mcpCapabilities')
  final McpCapabilities? mcpCapabilities;
  @JsonKey(name: 'promptCapabilities')
  final PromptCapabilities? promptCapabilities;
  @JsonKey(defaultValue: false)
  final bool loadSession;

  AgentCapabilities({
    this.meta,
    this.mcpCapabilities,
    this.promptCapabilities,
    this.loadSession = false,
  });

  factory AgentCapabilities.fromJson(Map<String, dynamic> json) =>
      _$AgentCapabilitiesFromJson(json);

  Map<String, dynamic> toJson() => _$AgentCapabilitiesToJson(this);
}

@JsonSerializable()
class McpCapabilities {
  @JsonKey(name: '_meta', includeIfNull: false)
  final Map<String, dynamic>? meta;
  @JsonKey(defaultValue: false)
  final bool http;
  @JsonKey(defaultValue: false)
  final bool sse;

  McpCapabilities({this.meta, this.http = false, this.sse = false});

  factory McpCapabilities.fromJson(Map<String, dynamic> json) =>
      _$McpCapabilitiesFromJson(json);

  Map<String, dynamic> toJson() => _$McpCapabilitiesToJson(this);
}

@JsonSerializable()
class PromptCapabilities {
  @JsonKey(name: '_meta', includeIfNull: false)
  final Map<String, dynamic>? meta;
  @JsonKey(defaultValue: false)
  final bool audio;
  @JsonKey(defaultValue: false)
  final bool embeddedContext;
  @JsonKey(defaultValue: false)
  final bool image;

  PromptCapabilities({
    this.meta,
    this.audio = false,
    this.embeddedContext = false,
    this.image = false,
  });

  factory PromptCapabilities.fromJson(Map<String, dynamic> json) =>
      _$PromptCapabilitiesFromJson(json);

  Map<String, dynamic> toJson() => _$PromptCapabilitiesToJson(this);
}

@JsonSerializable()
class AuthMethod {
  @JsonKey(name: '_meta', includeIfNull: false)
  final Map<String, dynamic>? meta;
  @JsonKey(name: 'id')
  final String id;
  final String name;
  final String? description;

  AuthMethod({
    this.meta,
    required this.id,
    required this.name,
    this.description,
  });

  factory AuthMethod.fromJson(Map<String, dynamic> json) =>
      _$AuthMethodFromJson(json);

  Map<String, dynamic> toJson() => _$AuthMethodToJson(this);
}

@JsonSerializable()
class AuthenticateResponse {
  @JsonKey(name: '_meta', includeIfNull: false)
  final Map<String, dynamic>? meta;

  AuthenticateResponse({this.meta});

  factory AuthenticateResponse.fromJson(Map<String, dynamic> json) =>
      _$AuthenticateResponseFromJson(json);

  Map<String, dynamic> toJson() => _$AuthenticateResponseToJson(this);
}

@JsonSerializable()
class NewSessionResponse {
  @JsonKey(name: '_meta', includeIfNull: false)
  final Map<String, dynamic>? meta;
  final String sessionId;
  final SessionModeState? modes;
  final SessionModelState? models;

  NewSessionResponse({
    this.meta,
    required this.sessionId,
    this.modes,
    this.models,
  });

  factory NewSessionResponse.fromJson(Map<String, dynamic> json) =>
      _$NewSessionResponseFromJson(json);

  Map<String, dynamic> toJson() => _$NewSessionResponseToJson(this);
}

@JsonSerializable()
class SessionModeState {
  @JsonKey(name: '_meta', includeIfNull: false)
  final Map<String, dynamic>? meta;
  @JsonKey(name: 'availableModes')
  final List<SessionMode> availableModes;
  @JsonKey(name: 'currentModeId')
  final String currentModeId;

  SessionModeState({
    this.meta,
    required this.availableModes,
    required this.currentModeId,
  });

  factory SessionModeState.fromJson(Map<String, dynamic> json) =>
      _$SessionModeStateFromJson(json);

  Map<String, dynamic> toJson() => _$SessionModeStateToJson(this);
}

@JsonSerializable()
class SessionMode {
  @JsonKey(name: '_meta', includeIfNull: false)
  final Map<String, dynamic>? meta;
  final String id;
  final String name;
  final String? description;

  SessionMode({
    this.meta,
    required this.id,
    required this.name,
    this.description,
  });

  factory SessionMode.fromJson(Map<String, dynamic> json) =>
      _$SessionModeFromJson(json);

  Map<String, dynamic> toJson() => _$SessionModeToJson(this);
}

@JsonSerializable()
class SessionModelState {
  @JsonKey(name: '_meta', includeIfNull: false)
  final Map<String, dynamic>? meta;
  @JsonKey(name: 'availableModels')
  final List<ModelInfo> availableModels;
  @JsonKey(name: 'currentModelId')
  final String currentModelId;

  SessionModelState({
    this.meta,
    required this.availableModels,
    required this.currentModelId,
  });

  factory SessionModelState.fromJson(Map<String, dynamic> json) =>
      _$SessionModelStateFromJson(json);

  Map<String, dynamic> toJson() => _$SessionModelStateToJson(this);
}

@JsonSerializable()
class ModelInfo {
  @JsonKey(name: '_meta', includeIfNull: false)
  final Map<String, dynamic>? meta;
  @JsonKey(name: 'modelId')
  final String modelId;
  final String name;
  final String? description;

  ModelInfo({
    this.meta,
    required this.modelId,
    required this.name,
    this.description,
  });

  factory ModelInfo.fromJson(Map<String, dynamic> json) =>
      _$ModelInfoFromJson(json);

  Map<String, dynamic> toJson() => _$ModelInfoToJson(this);
}

@JsonSerializable()
class LoadSessionResponse {
  @JsonKey(name: '_meta', includeIfNull: false)
  final Map<String, dynamic>? meta;
  final SessionModeState? modes;
  final SessionModelState? models;

  LoadSessionResponse({this.meta, this.modes, this.models});

  factory LoadSessionResponse.fromJson(Map<String, dynamic> json) =>
      _$LoadSessionResponseFromJson(json);

  Map<String, dynamic> toJson() => _$LoadSessionResponseToJson(this);
}

@JsonSerializable()
class SetSessionModeResponse {
  @JsonKey(name: '_meta', includeIfNull: false)
  final Map<String, dynamic>? meta;

  SetSessionModeResponse({this.meta});

  factory SetSessionModeResponse.fromJson(Map<String, dynamic> json) =>
      _$SetSessionModeResponseFromJson(json);

  Map<String, dynamic> toJson() => _$SetSessionModeResponseToJson(this);
}

@JsonSerializable()
class PromptResponse {
  @JsonKey(name: '_meta', includeIfNull: false)
  final Map<String, dynamic>? meta;

  /// Indicates why the agent stopped processing the turn.
  final StopReason stopReason;

  PromptResponse({this.meta, required this.stopReason});

  factory PromptResponse.fromJson(Map<String, dynamic> json) =>
      _$PromptResponseFromJson(json);

  Map<String, dynamic> toJson() => _$PromptResponseToJson(this);
}

@JsonSerializable()
class SetSessionModelResponse {
  @JsonKey(name: '_meta', includeIfNull: false)
  final Map<String, dynamic>? meta;

  SetSessionModelResponse({this.meta});

  factory SetSessionModelResponse.fromJson(Map<String, dynamic> json) =>
      _$SetSessionModelResponseFromJson(json);

  Map<String, dynamic> toJson() => _$SetSessionModelResponseToJson(this);
}

@JsonSerializable()
class WriteTextFileResponse {
  @JsonKey(name: '_meta', includeIfNull: false)
  final Map<String, dynamic>? meta;

  WriteTextFileResponse({this.meta});

  factory WriteTextFileResponse.fromJson(Map<String, dynamic> json) =>
      _$WriteTextFileResponseFromJson(json);

  Map<String, dynamic> toJson() => _$WriteTextFileResponseToJson(this);
}

@JsonSerializable()
class ReadTextFileResponse {
  @JsonKey(name: '_meta', includeIfNull: false)
  final Map<String, dynamic>? meta;
  final String content;

  ReadTextFileResponse({this.meta, required this.content});

  factory ReadTextFileResponse.fromJson(Map<String, dynamic> json) =>
      _$ReadTextFileResponseFromJson(json);

  Map<String, dynamic> toJson() => _$ReadTextFileResponseToJson(this);
}

abstract class RequestPermissionOutcome {}

@JsonSerializable()
class CancelledOutcome implements RequestPermissionOutcome {
  @JsonKey(name: '_meta', includeIfNull: false)
  final Map<String, dynamic>? meta;
  @JsonKey(name: 'outcome')
  final String outcome;

  CancelledOutcome({this.meta, this.outcome = 'cancelled'});

  factory CancelledOutcome.fromJson(Map<String, dynamic> json) =>
      _$CancelledOutcomeFromJson(json);

  Map<String, dynamic> toJson() => _$CancelledOutcomeToJson(this);
}

@JsonSerializable()
class SelectedOutcome implements RequestPermissionOutcome {
  @JsonKey(name: '_meta', includeIfNull: false)
  final Map<String, dynamic>? meta;
  @JsonKey(name: 'outcome')
  final String outcome;
  final String optionId;

  SelectedOutcome({
    this.meta,
    this.outcome = 'selected',
    required this.optionId,
  });

  factory SelectedOutcome.fromJson(Map<String, dynamic> json) =>
      _$SelectedOutcomeFromJson(json);

  Map<String, dynamic> toJson() => _$SelectedOutcomeToJson(this);
}

@JsonSerializable()
class RequestPermissionResponse {
  @JsonKey(name: '_meta', includeIfNull: false)
  final Map<String, dynamic>? meta;
  @RequestPermissionOutcomeConverter()
  final RequestPermissionOutcome outcome;

  RequestPermissionResponse({this.meta, required this.outcome});

  factory RequestPermissionResponse.fromJson(Map<String, dynamic> json) =>
      _$RequestPermissionResponseFromJson(json);

  Map<String, dynamic> toJson() => _$RequestPermissionResponseToJson(this);
}

@JsonSerializable()
class CreateTerminalResponse {
  @JsonKey(name: '_meta', includeIfNull: false)
  final Map<String, dynamic>? meta;
  final String terminalId;

  CreateTerminalResponse({this.meta, required this.terminalId});

  factory CreateTerminalResponse.fromJson(Map<String, dynamic> json) =>
      _$CreateTerminalResponseFromJson(json);

  Map<String, dynamic> toJson() => _$CreateTerminalResponseToJson(this);
}

@JsonSerializable()
class TerminalOutputResponse {
  @JsonKey(name: '_meta', includeIfNull: false)
  final Map<String, dynamic>? meta;
  final String output;
  final TerminalExitStatus? exitStatus;
  final bool truncated;

  TerminalOutputResponse({
    this.meta,
    required this.output,
    this.exitStatus,
    required this.truncated,
  });

  factory TerminalOutputResponse.fromJson(Map<String, dynamic> json) =>
      _$TerminalOutputResponseFromJson(json);

  Map<String, dynamic> toJson() => _$TerminalOutputResponseToJson(this);
}

@JsonSerializable()
class TerminalExitStatus {
  @JsonKey(name: '_meta', includeIfNull: false)
  final Map<String, dynamic>? meta;
  final int? exitCode;
  final String? signal;

  TerminalExitStatus({this.meta, this.exitCode, this.signal});

  factory TerminalExitStatus.fromJson(Map<String, dynamic> json) =>
      _$TerminalExitStatusFromJson(json);

  Map<String, dynamic> toJson() => _$TerminalExitStatusToJson(this);
}

@JsonSerializable()
class ReleaseTerminalResponse {
  @JsonKey(name: '_meta', includeIfNull: false)
  final Map<String, dynamic>? meta;

  ReleaseTerminalResponse({this.meta});

  factory ReleaseTerminalResponse.fromJson(Map<String, dynamic> json) =>
      _$ReleaseTerminalResponseFromJson(json);

  Map<String, dynamic> toJson() => _$ReleaseTerminalResponseToJson(this);
}

@JsonSerializable()
class WaitForTerminalExitResponse {
  @JsonKey(name: '_meta', includeIfNull: false)
  final Map<String, dynamic>? meta;
  final int? exitCode;
  final String? signal;

  WaitForTerminalExitResponse({this.meta, this.exitCode, this.signal});

  factory WaitForTerminalExitResponse.fromJson(Map<String, dynamic> json) =>
      _$WaitForTerminalExitResponseFromJson(json);

  Map<String, dynamic> toJson() => _$WaitForTerminalExitResponseToJson(this);
}

@JsonSerializable()
class KillTerminalCommandResponse {
  @JsonKey(name: '_meta', includeIfNull: false)
  final Map<String, dynamic>? meta;

  KillTerminalCommandResponse({this.meta});

  factory KillTerminalCommandResponse.fromJson(Map<String, dynamic> json) =>
      _$KillTerminalCommandResponseFromJson(json);

  Map<String, dynamic> toJson() => _$KillTerminalCommandResponseToJson(this);
}

/// Notification to cancel ongoing operations for a session.
///
/// See protocol docs: [Cancellation](https://agentclientprotocol.com/protocol/prompt-turn#cancellation)
@JsonSerializable()
class CancelNotification {
  @JsonKey(name: '_meta', includeIfNull: false)
  final Map<String, dynamic>? meta;

  /// The ID of the session to cancel operations for.
  final String sessionId;

  CancelNotification({this.meta, required this.sessionId});

  factory CancelNotification.fromJson(Map<String, dynamic> json) =>
      _$CancelNotificationFromJson(json);

  Map<String, dynamic> toJson() => _$CancelNotificationToJson(this);
}

// --- Extensibility Types ---

@JsonSerializable()
class ExtNotification {
  ExtNotification();
  factory ExtNotification.fromJson(Map<String, dynamic> json) =>
      _$ExtNotificationFromJson(json);
  Map<String, dynamic> toJson() => _$ExtNotificationToJson(this);
}

@JsonSerializable()
class ExtMethodRequest {
  ExtMethodRequest();
  factory ExtMethodRequest.fromJson(Map<String, dynamic> json) =>
      _$ExtMethodRequestFromJson(json);
  Map<String, dynamic> toJson() => _$ExtMethodRequestToJson(this);
}

@JsonSerializable()
class ExtMethodResponse {
  ExtMethodResponse();
  factory ExtMethodResponse.fromJson(Map<String, dynamic> json) =>
      _$ExtMethodResponseFromJson(json);
  Map<String, dynamic> toJson() => _$ExtMethodResponseToJson(this);
}

// --- Top-Level Union Types ---

/// All possible notifications that an agent can send to a client.
abstract class AgentNotification {}

/// All possible requests that an agent can send to a client.
abstract class AgentRequest {}

/// All possible responses that an agent can send to a client.
abstract class AgentResponse {}

/// Optional annotations for the client. The client can use annotations to inform how objects are used or displayed
@JsonSerializable()
class Annotations {
  @JsonKey(name: '_meta', includeIfNull: false)
  final Map<String, dynamic>? meta;
  final List<Role>? audience;
  final String? lastModified;
  final double? priority;

  Annotations({this.meta, this.audience, this.lastModified, this.priority});

  factory Annotations.fromJson(Map<String, dynamic> json) =>
      _$AnnotationsFromJson(json);

  Map<String, dynamic> toJson() => _$AnnotationsToJson(this);
}

/// Text-based resource contents.
@JsonSerializable()
class TextResourceContents extends EmbeddedResourceResource {
  @JsonKey(name: '_meta', includeIfNull: false)
  final Map<String, dynamic>? meta;
  final String? mimeType;
  final String text;
  final String uri;

  TextResourceContents({
    this.meta,
    this.mimeType,
    required this.text,
    required this.uri,
  });

  factory TextResourceContents.fromJson(Map<String, dynamic> json) =>
      _$TextResourceContentsFromJson(json);

  Map<String, dynamic> toJson() => _$TextResourceContentsToJson(this);
}

/// Binary resource contents.
@JsonSerializable()
class BlobResourceContents extends EmbeddedResourceResource {
  @JsonKey(name: '_meta', includeIfNull: false)
  final Map<String, dynamic>? meta;
  final String? mimeType;
  final String blob;
  final String uri;

  BlobResourceContents({
    this.meta,
    this.mimeType,
    required this.blob,
    required this.uri,
  });

  factory BlobResourceContents.fromJson(Map<String, dynamic> json) =>
      _$BlobResourceContentsFromJson(json);

  Map<String, dynamic> toJson() => _$BlobResourceContentsToJson(this);
}

/// Resource content that can be embedded in a message.
abstract class EmbeddedResourceResource {}

@JsonSerializable()
class EmbeddedResource {
  @JsonKey(name: '_meta', includeIfNull: false)
  final Map<String, dynamic>? meta;
  final Annotations? annotations;
  @EmbeddedResourceResourceConverter()
  final EmbeddedResourceResource resource;

  EmbeddedResource({this.meta, this.annotations, required this.resource});

  factory EmbeddedResource.fromJson(Map<String, dynamic> json) =>
      _$EmbeddedResourceFromJson(json);

  Map<String, dynamic> toJson() => _$EmbeddedResourceToJson(this);
}

/// Content produced by a tool call.
///
/// Tool calls can produce different types of content including
/// standard content blocks (text, images) or file diffs.
///
/// See protocol docs: [Content](https://agentclientprotocol.com/protocol/tool-calls#content)
abstract class ToolCallContent {}

@JsonSerializable()
class ContentToolCallContent extends ToolCallContent {
  @JsonKey(name: '_meta', includeIfNull: false)
  final Map<String, dynamic>? meta;
  @JsonKey(name: 'type', defaultValue: 'content')
  final String type = 'content';
  @ContentBlockConverter()
  final ContentBlock content;

  ContentToolCallContent({this.meta, required this.content});

  factory ContentToolCallContent.fromJson(Map<String, dynamic> json) =>
      _$ContentToolCallContentFromJson(json);

  Map<String, dynamic> toJson() => _$ContentToolCallContentToJson(this);
}

@JsonSerializable()
class DiffToolCallContent extends ToolCallContent {
  @JsonKey(name: '_meta', includeIfNull: false)
  final Map<String, dynamic>? meta;
  @JsonKey(name: 'type', defaultValue: 'diff')
  final String type = 'diff';
  final String newText;
  final String? oldText;
  final String path;

  DiffToolCallContent({
    this.meta,
    required this.newText,
    this.oldText,
    required this.path,
  });

  factory DiffToolCallContent.fromJson(Map<String, dynamic> json) =>
      _$DiffToolCallContentFromJson(json);

  Map<String, dynamic> toJson() => _$DiffToolCallContentToJson(this);
}

@JsonSerializable()
class TerminalToolCallContent extends ToolCallContent {
  @JsonKey(name: '_meta', includeIfNull: false)
  final Map<String, dynamic>? meta;
  @JsonKey(name: 'type', defaultValue: 'terminal')
  final String type = 'terminal';
  final String terminalId;

  TerminalToolCallContent({this.meta, required this.terminalId});

  factory TerminalToolCallContent.fromJson(Map<String, dynamic> json) =>
      _$TerminalToolCallContentFromJson(json);

  Map<String, dynamic> toJson() => _$TerminalToolCallContentToJson(this);
}

/// A file location being accessed or modified by a tool.
///
/// Enables clients to implement "follow-along" features that track
/// which files the agent is working with in real-time.
///
/// See protocol docs: [Following the Agent](https://agentclientprotocol.com/protocol/tool-calls#following-the-agent)
@JsonSerializable()
class ToolCallLocation {
  @JsonKey(name: '_meta', includeIfNull: false)
  final Map<String, dynamic>? meta;

  /// Optional line number within the file.
  final int? line;

  /// The file path being accessed or modified.
  final String path;

  ToolCallLocation({this.meta, this.line, required this.path});

  factory ToolCallLocation.fromJson(Map<String, dynamic> json) =>
      _$ToolCallLocationFromJson(json);

  Map<String, dynamic> toJson() => _$ToolCallLocationToJson(this);
}

/// A single entry in the execution plan.
///
/// Represents a task or goal that the assistant intends to accomplish
/// as part of fulfilling the user's request.
/// See protocol docs: [Plan Entries](https://agentclientprotocol.com/protocol/agent-plan#plan-entries)
@JsonSerializable()
class PlanEntry {
  @JsonKey(name: '_meta', includeIfNull: false)
  final Map<String, dynamic>? meta;

  final String content;

  @JsonKey(name: 'priority')
  final PlanEntryPriority priority;

  @JsonKey(name: 'status')
  final PlanEntryStatus status;

  PlanEntry({
    this.meta,
    required this.content,
    required this.priority,
    required this.status,
  });

  factory PlanEntry.fromJson(Map<String, dynamic> json) =>
      _$PlanEntryFromJson(json);

  Map<String, dynamic> toJson() => _$PlanEntryToJson(this);
}

@JsonSerializable()
class Plan {
  @JsonKey(name: '_meta', includeIfNull: false)
  final Map<String, dynamic>? meta;
  final List<PlanEntry> entries;

  Plan({this.meta, required this.entries});

  factory Plan.fromJson(Map<String, dynamic> json) => _$PlanFromJson(json);

  Map<String, dynamic> toJson() => _$PlanToJson(this);
}

enum PlanEntryPriority {
  @JsonValue('high')
  high,
  @JsonValue('medium')
  medium,
  @JsonValue('low')
  low,
}

enum PlanEntryStatus {
  @JsonValue('pending')
  pending,
  @JsonValue('in_progress')
  inProgress,
  @JsonValue('completed')
  completed,
}

/// The input specification for a command.
abstract class AvailableCommandInput {}

/// All text that was typed after the command name is provided as input.
@JsonSerializable()
class UnstructuredCommandInput extends AvailableCommandInput {
  @JsonKey(name: '_meta', includeIfNull: false)
  final Map<String, dynamic>? meta;

  /// A hint to display when the input hasn't been provided yet
  final String hint;

  UnstructuredCommandInput({this.meta, required this.hint});

  factory UnstructuredCommandInput.fromJson(Map<String, dynamic> json) =>
      _$UnstructuredCommandInputFromJson(json);

  Map<String, dynamic> toJson() => _$UnstructuredCommandInputToJson(this);
}

/// Information about a command.
@JsonSerializable()
class AvailableCommand {
  @JsonKey(name: '_meta', includeIfNull: false)
  final Map<String, dynamic>? meta;

  /// Human-readable description of what the command does.
  final String description;

  /// Input for the command if required
  final UnstructuredCommandInput? input;

  /// Command name (e.g., `create_plan`, `research_codebase`).
  final String name;

  AvailableCommand({
    this.meta,
    required this.description,
    this.input,
    required this.name,
  });

  factory AvailableCommand.fromJson(Map<String, dynamic> json) =>
      _$AvailableCommandFromJson(json);

  Map<String, dynamic> toJson() => _$AvailableCommandToJson(this);
}

/// Notification containing a session update from the agent.
///
/// Used to stream real-time progress and results during prompt processing.
///
/// See protocol docs: [Agent Reports Output](https://agentclientprotocol.com/protocol/prompt-turn#3-agent-reports-output)
@JsonSerializable()
class SessionNotification {
  @JsonKey(name: '_meta', includeIfNull: false)
  final Map<String, dynamic>? meta;

  /// The ID of the session this update pertains to.
  final String sessionId;

  /// The actual update content.
  @SessionUpdateConverter()
  final SessionUpdate update;

  SessionNotification({
    this.meta,
    required this.sessionId,
    required this.update,
  });

  factory SessionNotification.fromJson(Map<String, dynamic> json) =>
      _$SessionNotificationFromJson(json);

  Map<String, dynamic> toJson() => _$SessionNotificationToJson(this);
}

@JsonSerializable()
class UserMessageChunkSessionUpdate extends SessionUpdate {
  @ContentBlockConverter()
  final ContentBlock content;

  UserMessageChunkSessionUpdate({required this.content});

  factory UserMessageChunkSessionUpdate.fromJson(Map<String, dynamic> json) =>
      _$UserMessageChunkSessionUpdateFromJson(json);

  Map<String, dynamic> toJson() => _$UserMessageChunkSessionUpdateToJson(this);
}

@JsonSerializable()
class AgentMessageChunkSessionUpdate extends SessionUpdate {
  @ContentBlockConverter()
  final ContentBlock content;

  AgentMessageChunkSessionUpdate({required this.content});

  factory AgentMessageChunkSessionUpdate.fromJson(Map<String, dynamic> json) =>
      _$AgentMessageChunkSessionUpdateFromJson(json);

  Map<String, dynamic> toJson() => _$AgentMessageChunkSessionUpdateToJson(this);
}

@JsonSerializable()
class AgentThoughtChunkSessionUpdate extends SessionUpdate {
  @ContentBlockConverter()
  final ContentBlock content;

  AgentThoughtChunkSessionUpdate({required this.content});

  factory AgentThoughtChunkSessionUpdate.fromJson(Map<String, dynamic> json) =>
      _$AgentThoughtChunkSessionUpdateFromJson(json);

  Map<String, dynamic> toJson() => _$AgentThoughtChunkSessionUpdateToJson(this);
}

abstract class SessionUpdate {}

@JsonSerializable()
class ToolCallSessionUpdate extends SessionUpdate {
  @JsonKey(name: '_meta', includeIfNull: false)
  final Map<String, dynamic>? meta;
  @ToolCallContentConverter()
  final List<ToolCallContent>? content;
  final ToolKind? kind;
  final List<ToolCallLocation>? locations;
  final Map<String, dynamic>? rawInput;
  final Map<String, dynamic>? rawOutput;
  final ToolCallStatus? status;
  final String title;
  final String toolCallId;

  ToolCallSessionUpdate({
    this.meta,
    this.content,
    this.kind,
    this.locations,
    this.rawInput,
    this.rawOutput,
    this.status,
    required this.title,
    required this.toolCallId,
  });

  factory ToolCallSessionUpdate.fromJson(Map<String, dynamic> json) =>
      _$ToolCallSessionUpdateFromJson(json);

  Map<String, dynamic> toJson() => _$ToolCallSessionUpdateToJson(this);
}

@JsonSerializable()
class ToolCallUpdateSessionUpdate extends SessionUpdate {
  @JsonKey(name: '_meta', includeIfNull: false)
  final Map<String, dynamic>? meta;
  @ToolCallContentConverter()
  final List<ToolCallContent>? content;
  final ToolKind? kind;
  final List<ToolCallLocation>? locations;
  final Map<String, dynamic>? rawInput;
  final Map<String, dynamic>? rawOutput;
  final ToolCallStatus? status;
  final String? title;
  final String toolCallId;

  ToolCallUpdateSessionUpdate({
    this.meta,
    this.content,
    this.kind,
    this.locations,
    this.rawInput,
    this.rawOutput,
    this.status,
    this.title,
    required this.toolCallId,
  });

  factory ToolCallUpdateSessionUpdate.fromJson(Map<String, dynamic> json) =>
      _$ToolCallUpdateSessionUpdateFromJson(json);

  Map<String, dynamic> toJson() => _$ToolCallUpdateSessionUpdateToJson(this);
}

@JsonSerializable()
class PlanSessionUpdate extends SessionUpdate {
  @JsonKey(name: '_meta', includeIfNull: false)
  final Map<String, dynamic>? meta;
  final List<PlanEntry> entries;

  PlanSessionUpdate({this.meta, required this.entries});

  factory PlanSessionUpdate.fromJson(Map<String, dynamic> json) =>
      _$PlanSessionUpdateFromJson(json);

  Map<String, dynamic> toJson() => _$PlanSessionUpdateToJson(this);
}

@JsonSerializable()
class AvailableCommandsUpdateSessionUpdate extends SessionUpdate {
  @JsonKey(name: '_meta', includeIfNull: false)
  final Map<String, dynamic>? meta;
  final List<AvailableCommand> availableCommands;

  AvailableCommandsUpdateSessionUpdate({
    this.meta,
    required this.availableCommands,
  });

  factory AvailableCommandsUpdateSessionUpdate.fromJson(
    Map<String, dynamic> json,
  ) => _$AvailableCommandsUpdateSessionUpdateFromJson(json);

  Map<String, dynamic> toJson() =>
      _$AvailableCommandsUpdateSessionUpdateToJson(this);
}

@JsonSerializable()
class CurrentModeUpdateSessionUpdate extends SessionUpdate {
  @JsonKey(name: '_meta', includeIfNull: false)
  final Map<String, dynamic>? meta;
  final String currentModeId;

  CurrentModeUpdateSessionUpdate({this.meta, required this.currentModeId});

  factory CurrentModeUpdateSessionUpdate.fromJson(Map<String, dynamic> json) =>
      _$CurrentModeUpdateSessionUpdateFromJson(json);

  Map<String, dynamic> toJson() => _$CurrentModeUpdateSessionUpdateToJson(this);
}

@JsonSerializable()
class UnknownSessionUpdate extends SessionUpdate {
  final Map<String, dynamic> rawJson;
  UnknownSessionUpdate({required this.rawJson});
  factory UnknownSessionUpdate.fromJson(Map<String, dynamic> json) =>
      _$UnknownSessionUpdateFromJson(json);
  Map<String, dynamic> toJson() => _$UnknownSessionUpdateToJson(this);
}

/// Protocol method constants for agent-side requests
const agentMethods = {
  'authenticate': 'authenticate',
  'initialize': 'initialize',
  'modelSelect': 'session/set_model',
  'sessionCancel': 'session/cancel',
  'sessionLoad': 'session/load',
  'sessionNew': 'session/new',
  'sessionPrompt': 'session/prompt',
  'sessionSetMode': 'session/set_mode',
};

/// Protocol method constants for client-side requests
const clientMethods = {
  'fsReadTextFile': 'fs/read_text_file',
  'fsWriteTextFile': 'fs/write_text_file',
  'sessionRequestPermission': 'session/request_permission',
  'sessionUpdate': 'session/update',
  'terminalCreate': 'terminal/create',
  'terminalKill': 'terminal/kill',
  'terminalOutput': 'terminal/output',
  'terminalRelease': 'terminal/release',
  'terminalWaitForExit': 'terminal/wait_for_exit',
};
